# Звіт по комп'ютерному проекту.
## Тема проекту: 
Знайти найкоротший шлях між двома точками поверхні.
## Мета проєкту: 
Розробка ефективного алгоритму для пошуку найкоротшого шляху між двома точками на поверхні з використанням сучасних алгоритмічних підходів.
## Виконавці: 
Шевчук Дарина, Свириденко Ірина, Гобела Максим, Карпіна Олеся, Шопська Анастасія. 
## Вибір алгортмів:
Під час підготовки до написання коду ми вивчали різні алгоритми із пошуку найкоротшої відстані між вома точками поверхні і зупинились на алгоритмі із назвою А*, що пердбачає  використання евристичної оцінки для скорочення кількості вузлів, які потрібно перевірити під час пошуку найкоротшого шляху, що забезпечує його ефективність та оптимальність. 
### Огляд досліджених алгоритмів
У процесі роботи над проєктом ми провели ґрунтовне дослідження різних алгоритмів пошуку найкоротшого шляху:
1) Алгоритм Дейкстри
Класичний метод пошуку найкоротшого шляху
Переваги: простота реалізації
Обмеження: не працює з від'ємними вагами ребер.
2) Алгоритм Беллмана-Форда
Переваги: працює з графами, що містять від'ємні ваги ребер, може виявляти наявність негативних циклів у графі(цикли (послідовності вершин, які починаються і закінчуються в одній і тій самій вершині)
з від'ємною сумою ваг ребер).
Недоліки: cкладніший у реалізації, ніж алгоритм Дейкстри.
Працює повільніше, особливо на великих графах
3) Алгоритм A* (A-зірочка)
Переваги: використовує евристичні оцінки для пріоритетного пошуку, що знижує кількість перевірених вершин для результату, значно швидший,ефективніший за класичний алгоритм Дейкстри.
Недоліки: потребує обґрунтованої евристичної функції для коректної та ефективної роботи.
У деяких випадках може споживати значний обсяг пам’яті через використання пріоритетної черги(у даному випадку найменший пріоритет означає найменшу вартість шляху(найменшу евристичну оцінку)).
### Обґрунтування вибору алгоритму
Після детального аналізу та тестування різних підходів, ми зупинилися на алгоритмі A* (A-зірочка) з наступних причин:
1) Висока ефективність пошуку
2) Можливість використання евристичних оцінок
3) Гарантована оптимальність результату
4) Краща продуктивність на великих графах
5) Гнучкість у налаштуванні евристичної функції
При написанні самого коду ми інтерпретували алгоритм А* за допомогю коду Python та візуалізували його.
### Теоретичні основи алгоритму A*:
Алгоритм A* є різновидом алгоритмів пошуку найкоротшого шляху, який використовує евристичну оптимізацію. Його ключова особливість - функція оцінки вузла.
#### Еврестична функція
Евристична функція - це метод наближеного оцінювання найкращого шляху до мети, кінцевої точки.
Кожен вузол оцінюється за двома параметрами: реальна відстань від старту до поточного вузла
та евристична оцінка відстані від поточного вузла до мети.
На кожній ітерації алгоритм вибирає найперспективніший вузол 
та оцінює його сусідів, поступово звужуючи простір пошуку.
Зупиняється така функція тоді, коли  або досягнуто цільової точки, або вичерпано усі можливі варіанти,
або перевищено максимальну кількість ітерацій.
## Реалізація алгоритму:
### 1. використані бібліотеки:
1) import argparse - бібліотека для обробки аргументів командного рядка
2) import random - для генерації випадкових стартових і кінцевих позицій
3) from datetime import datetime - для вимірювання часу виконання
4) import heapq - для реалізації черги з пріоритетом у алгоритмі A*
5) import numpy as np - для роботи з числовими матрицями
6) from numba import jit - для оптимізації критичних за швидкістю функцій
### 2. функція create_node
Створює вузол для алгоритму A*. Потрібна для збереження інформації про вузол у зручному форматі, а саме словнику.Вузол містить: координати, вартість шляху до вузла,
евристичну оцінку до цілі, сумарну оцінку вартості шляху та еврестичної оцінки і посилання на батьківський вузол.
### 3. функція neighbor_nodes
Функція знаходить сусідні вузли для заданої точки й потрібна для визначення всіх допустимих, а тобто тих,
що не виходять за межі матриці,сусідніх вузлів, які використовуються алгоритмом A*.
```python
def neighbor_nodes(point, rows, cols) -> list:
    totresult = []  # Список для збереження коректних сусідів
        result = [(point[0] + 1, point[1]), (point[0] - 1, point[1]),
                (point[0], point[1] + 1), (point[0], point[1] - 1)]  # Можливі сусіди
        for pair in result:
            # Перевірка, чи координати не виходять за межі матриці
            if 0 <= pair[0] < rows and 0 <= pair[1] < cols:
                totresult.append(pair)
        return totresult  # Повернення списку сусідів
```
### 4. функція h_x
Обчислює евристичну функцію від поточної точки до цілі.
Потрібна для оцінки "відстані" до цілі, щоб алгоритм A* зміг ефективніше
вибирати вузли для пошуку.
```python
def h_x(curr_point, goal):
    return abs(curr_point[0] - goal[0]) + abs(curr_point[1] - goal[1])
```
### 5. функція g_x
Знаходить вартість шляху від старту до поточної точки.
Функція необхідна для врахування реальної вартості проходження між точками, 
включаючи різницю висот.
``` python
def g_x(curr_height, start_height, step=1):
    distance = curr_height - start_height  # Різниця висот
    return (step ** 2 + distance ** 2) ** 0.5
```
### 6. функція astar_search
Реалізує алгоритм A* для знаходження найкоротшого шляху.
Ця функція є основою, що виконує пошук шляху від стартової
до кінцевої точки, враховуючи вартість шляху та евристичну оцінку із двох попередніх функцій, наведених вище.
Логіка роботи:
1. Ініціалізація:
 - Визначаємо розміри матриці.
 - Створюємо початковий вузол (start_node) з вартістю g=0 і h=оцінка до цілі.
 - Додаємо цей вузол до відкритого набору (open_set).
2. Цикл пошуку:
 - Вибираємо вузол з найменшою оцінкою f (з пріоритетної черги).
 - Якщо цей вузол — ціль, будуємо і повертаємо шлях.
 - Додаємо вузол до закритого набору (оброблених вузлів).
 - Знаходимо сусідів для поточного вузла:
 - Обчислюємо вартість g для сусідів.
 - Якщо сусід ще не в обробці або має кращу оцінку g, оновлюємо дані вузла.
 - Додаємо вузол у відкритий набір.
якщо шлях знайдено, повертаємо список координат вузлів, які формують найкоротший шлях від старту до цілі.
``` python
  rows, cols = matr.shape  # Розмір матриці
    closed_set = set()  # Вузли, які вже оброблені
    start_node = create_node(position=start, g=0, h=h_x(start, goal))  # Початковий вузол
    open_set = [(start_node['f'], start)]  # Черга з пріоритетом (відкриті вузли)
    node_map = {start: start_node}  # Словник для зберігання вузлів за їх координатами

    while open_set:
        _, current_pos = heapq.heappop(open_set)  # Вибір вузла з найменшим f
        current_node = node_map[current_pos]  # Поточний вузол

        if current_pos == goal:  # Якщо досягнуто ціль
            path = []
            while current_node:
                path.insert(0, current_node["position"])  # Відновлення шляху
                current_node = current_node["parent"]
            return path  # Повернення найкоротшого шляху

        closed_set.add(current_node["position"])  # Додавання вузла до закритого набору

        for neighbor in neighbor_nodes(current_node["position"], rows, cols):
            if neighbor in closed_set:
                continue

            cost = current_node["g"] + g_x(matr[current_node["position"]], matr[neighbor])
            neighbor_node = create_node(position=neighbor, g=cost, h=h_x(neighbor, goal),
                                        parent=current_node)

            if neighbor not in node_map or node_map[neighbor]["g"] > cost:
                node_map[neighbor] = neighbor_node  # Оновлення інформації про вузол
                heapq.heappush(open_set, (neighbor_node['f'], neighbor))  # Додавання у відкритий набір

    return None  # Повернення None, якщо шлях не знайдено
```
### 7. функція generate_matrix
Генерує матрицю випадкових чисел заданого розміру.
Використовується для створення вхідної матриці висот,з якою працюватиме алгоритм A*.
### 8. функція main()
Основна функція для запуску програми. Вона обробляє аргументи командного рядка, задаються розміри матриці, генерується випадкова матриця висот генерує матрицю, обирає стартову і кінцеву точку, викликає `astar_search` для знаходження найкоротшого шляху та виводить результати, що залежать від того, чи знайдений шлях. Також вимірюється і виводиться загальний час виконання програми.
``` python
def main():
    parser = argparse.ArgumentParser(description="Алгоритм A* для пошуку шляху")
        parser.add_argument("--rows", type=int, default=10000, help="Кількість рядків у матриці")
        parser.add_argument("--cols", type=int, default=10000, help="Кількість стовпців у матриці")

        args = parser.parse_args()

        rows, cols = args.rows, args.cols #кількість рядків у матриці, rількість стовпців у матриці

        matrix = generate_matrix(rows, cols)  # Генерація матриці

        start = (random.randint(0, rows - 1), random.randint(0, cols - 1))  # Випадкова стартова точка
        goal = (random.randint(0, rows - 1), random.randint(0, cols - 1))  # Випадкова кінцева точка

        print("Старт:", start)
        print("Ціль:", goal)

        path = astar_search(matrix, start, goal)  # Виконання алгоритму A*

        if path:
            print("Знайдений шлях:", len(path), path)
        else:
            print("Шлях не знайдено.")

        end_time = datetime.now()  # Час завершення
        print(f"Час виконання: {end_time - start_time}")
```
## Візуалізація:
Працюючи над проєктом, ми також створили інтерактивне графічне представлення шляху між початковою
та кінцевою точками з використанням бібліотеки Pygame.
### Ключові функції:
#### 1. функція dist_visualise
Основна функція, яка налаштовує візуалізацію. 
Приймає параметри ширини та висоти сітки, початкової та кінцевої точок, 
а також шляху, створює вікно, масштабоване відповідно до розмірів сітки та 
використовує різні зображення для представлення елементів візуалізації.
#### 2. функція launch()
функція запускає головний цикл програми, який відображає графічний інтерфейс, 
включаючи фон, стартову і фінішну точки, а також анімацію шляху. Працює безперервно до завершення програми
### Особливості та деталі: 
Код візуалізації випадково заповнює фон зображеннями, дозволяє покроково відображати шлях
з затримкою, використовує Pygame для відображення графіки, 
підтримує налаштування розмірів сітки, забезпечує саме анімовану візуалізацію шляху, 
фон заповнюється випадково вибраними зображеннями зі списку, 
а шлях промальовується поступово.
Скрипт вимагає наявності кількох файлів зображень:
 -lisa.png, dutchgirl.png, murashko.png, frenchgirl.png, kasiyan.png: фонові зображення
 -first.png: маркер початкової точки
 -last.png: маркер кінцевої точки
 -path.png: маркер візуалізації шляху
## Розподіл роботи:
### інтерпретування алгоритму в код:
 - Шевчук Дарина
 - Свириденко Ірина
 - Карпіна Олеся
### Візуальна частина коду:
 - Гобела Максим
 - Шопська Анастасія
### Відповідальні за звіт, презентація:
 - Карпіна Олеся
 - Шопська Анастасія
## Висновки:
У ході роботи над проєктом ми:
- Провели ґрунтовний аналіз алгоритмів пошуку найкоротшого шляху
- Обґрунтували вибір алгоритму A* як найбільш ефективного рішення
- Розробили та реалізували алгоритм пошуку найкоротшого шляху
- Провели тестування та верифікацію результатів
Ми довели високу швидкість A* порівняно з альтернативними методами, підтвердили оптимальність знаходження найкоротшого шляху, досягнули мінімізації обчислювальних витрат. Проведене дослідження показало, що алгоритм A* є потужним інструментом для пошуку найкоротшого шляху завдяки 1ого гнучкості, ефективності та можливості адаптації.
